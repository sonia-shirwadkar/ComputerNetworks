{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nIn this project, we will build a storage system that uses sharding and replication to the improve robustness of the storage service. The system shares key design ideas with some of the online storage/file sharing systems.\nIn our system, the client may partitions the data it needs to upload into a number of partitions (e.g., 3 in our project) and upload it to three different servers. We call these shards. There could be many reasons for sharding. A widely used reason is to put different parts of the dataset on different servers to optimize download and upload speeds.\n\n\nMain components\n\n\nThe proposed system is a two-tiered client-server application and includes two main components and one diagnostic utility.\n\n\n\n\nShard: \n\nThe shard is responsible for storing data uploaded by the client and also for providing the content to the client when requested.\n\n\nClient: \n\nThe client program uploads and downloads data to/from the shards\n\n\nMonitor: \n\nThe monitor module is responsible for querying the storage capacity used at each of the shards and recoding the results in a CSV file. This module is used to verify whether the load-balancing algorithm functions as expected or not.\n\n\n\n\nCommunication protocol\n\n\nThe client and shard communicate with each other using a custom JSON protocol. The messages exchanged are as follows:\n\n\n1. CLIENT or MONITOR requests SHARD for number of bytes stored\n            MessageType: \u201cBYTESTORED\u201d\n\n2. CLIENT sends part of file to a SHARD\n            MessageType: \u201cDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:\n\n3. CLIENT requests SHARD for information of a file\n            MessageType: \u201cFILEINFO\u201d\n            Filename:\n\n4. CLIENT requests SHARD for specific bytes of a file\n            MessageType: \u201cREQUESTDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n\n5. SHARD sends CLIENT the number of bytes stored\n            MessageType: \u201cBYTESTORED\u201d\n            BytesStored: \nvalue in bytes\n\n\n6. SHARD sends CLIENT information of a file\n            MessageType: \u201cFILEINFO\u201d\n            Filename:\n            BytesFrom:\n            BytesTo:\n            BytesFrom2: \nfor copy from SHARD 2\n\n            BytesTo2: \nfor copy from SHARD 2\n\n            BytesFrom3: \nfor copy from SHARD 3\n\n            BytesTo3: \nfor copy from SHARD 3\n\n\n7. SHARD sends CLIENT specific bytes of a file\n            MessageType: \u201cDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:\n\n8. SHARD sends another SHARD specific bytes of a file\n            MessageType: \u201cBACKUPDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "In this project, we will build a storage system that uses sharding and replication to the improve robustness of the storage service. The system shares key design ideas with some of the online storage/file sharing systems.\nIn our system, the client may partitions the data it needs to upload into a number of partitions (e.g., 3 in our project) and upload it to three different servers. We call these shards. There could be many reasons for sharding. A widely used reason is to put different parts of the dataset on different servers to optimize download and upload speeds.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#main-components", 
            "text": "The proposed system is a two-tiered client-server application and includes two main components and one diagnostic utility.   Shard:  \nThe shard is responsible for storing data uploaded by the client and also for providing the content to the client when requested.  Client:  \nThe client program uploads and downloads data to/from the shards  Monitor:  \nThe monitor module is responsible for querying the storage capacity used at each of the shards and recoding the results in a CSV file. This module is used to verify whether the load-balancing algorithm functions as expected or not.", 
            "title": "Main components"
        }, 
        {
            "location": "/#communication-protocol", 
            "text": "The client and shard communicate with each other using a custom JSON protocol. The messages exchanged are as follows:  1. CLIENT or MONITOR requests SHARD for number of bytes stored\n            MessageType: \u201cBYTESTORED\u201d\n\n2. CLIENT sends part of file to a SHARD\n            MessageType: \u201cDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:\n\n3. CLIENT requests SHARD for information of a file\n            MessageType: \u201cFILEINFO\u201d\n            Filename:\n\n4. CLIENT requests SHARD for specific bytes of a file\n            MessageType: \u201cREQUESTDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n\n5. SHARD sends CLIENT the number of bytes stored\n            MessageType: \u201cBYTESTORED\u201d\n            BytesStored:  value in bytes \n\n6. SHARD sends CLIENT information of a file\n            MessageType: \u201cFILEINFO\u201d\n            Filename:\n            BytesFrom:\n            BytesTo:\n            BytesFrom2:  for copy from SHARD 2 \n            BytesTo2:  for copy from SHARD 2 \n            BytesFrom3:  for copy from SHARD 3 \n            BytesTo3:  for copy from SHARD 3 \n\n7. SHARD sends CLIENT specific bytes of a file\n            MessageType: \u201cDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:\n\n8. SHARD sends another SHARD specific bytes of a file\n            MessageType: \u201cBACKUPDATA\u201d\n            Filename:\n            BytesFrom:     \n            BytesTo:\n            Data:", 
            "title": "Communication protocol"
        }, 
        {
            "location": "/shardapi/", 
            "text": "Shard\n\n\nThe shard is responsible for storing the files. To simplify this project, we will have shards also be the backups and develop the system so that it can tolerate the failure of one shard. Further, the system will support exactly three shards but the IP address and ports should not be hard coded in your code. Each shard connects to the other two shards, shard1 and shard2.\nThe shards, when they receive an upload file, they split the file into two equal parts and upload the \"backup\" to the other two shards. Thus each upload chunk is tagged as primary or backup on the shard. When calculating the total storage used on a shard, it reports the total of primary and backup storage.\nThe shard listens to the incoming connections from the clients. It also connects to the other shards in the network. It keeps a metadata of all the uploaded files and replicated files as backup.\n\n\nReplication\n\n\nIn many distributed systems, such as storage systems in the cloud, the same data is copied to multiple servers in multiple geographical locations. Such copies of data are called replicas. Replicas are used to provide redundancy and reliability to storage system, i.e., if one copy of the data is lost, we still have another copy. In our project, we will replicate the data stored in the shards so that the system can survive the crash of one shard.\nIn this project, we will have each shard split the data it receives for storage into two pieces and copy them to the remaining two servers. That way, if a shard crashes, we have a copy of the data on the two remaining servers. The system will not be able to recover if more than one shard crashes.\n\n\nSystem Components\n\n\nThe shards are configured at start-up using a configuration file. Also, the shards store all metadata related to uploaded data in the metadata file.\nThe description and structure ofboth these files is presented below.\n\n\nConfiguration file\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhomedir\n\n\nHome directory for the shard and client. Each client and shard has a different home directory\n\n\n\n\n\n\nlistenport\n\n\nPort at which this shard should listen for incoming connections\n\n\n\n\n\n\nmetadatafile\n\n\nThe file that stores the metadata corresponding to the files and replicates stored by the shard\n\n\n\n\n\n\nshard1ip\n\n\nIP address of shard 1\n\n\n\n\n\n\nshard1port\n\n\nPort of shard 1\n\n\n\n\n\n\nshard2ip\n\n\nIP address of shard 2\n\n\n\n\n\n\nshard2port\n\n\nPort of shard 2\n\n\n\n\n\n\n\n\nMetadata\n\n\nThe home directory for the shard contains a metadata file specified in the configuration file. The metadata has information about the primary and backup data stored by the shard. This file is JSON format and contains the following fields:\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFilename\n\n\nName of the file for which metadata is stored\n\n\n\n\n\n\nBytesFrom1\n\n\nStart index of primary data block\n\n\n\n\n\n\nBytesTo1\n\n\nEnd index of primary data block\n\n\n\n\n\n\nFilename2\n\n\nName of the file for first backup block received from other shards\n\n\n\n\n\n\nBytesFrom2\n\n\nStart index of first backup data block\n\n\n\n\n\n\nBytesTo2\n\n\nEnd index of first backup data block\n\n\n\n\n\n\nFilename3\n\n\nName of the file for second backup block received from other shards\n\n\n\n\n\n\nBytesFrom3\n\n\nStart index of second backup data block\n\n\n\n\n\n\nBytesTo3\n\n\nEnd index of second backup data block\n\n\n\n\n\n\n\n\nAPI Documentation\n\n\n\n\nThe entire module has been developed using Python. The shard functionality is implemented using two classes\n\n\n\n\n\n\nShard: \n\n   This is the main class for the shard and is responsible for listening for incoming client requests\n\n\n\n\n\n\nServerThread: \n\n   This class is the main engine for the shard functionality. It derives from thread.Threading class. The Shard class creates an instance of this class\n   and passes all requests received from client to this instance. The ServerThread instance is then responsible for replying to all requests\n\n\n\n\n\n\nThe API documentation discussed below pertain to the ServerThread class unless otherwise mentioned\n\n\n\n\nAccepting client requests\n\n\nThis function is the main engine of the ServerThread class. This function is responsible for determining the type of client request received\nand taking action accordingly.\n\n\nacceptClientRequests()\n\n\n\n\nInput parameters:\n    None\n\nReturn:\n    None\n\n\n\nKnown Limitations: To parse the JSON message received, it is assumed that the message won't won't contain more than one '}'\n\n\n\n\nSending used storage capacity to the client\n\n\nThe client requests the shard for the current used storage capacity using the following message\n\n\n{\n    MessageType: \"BYTESTORED\"\n    ByteStored: \"\nvalue in bytes\n\"\n}\n\n\n\nsendShardCapacity() function is responsible for responding to the \"BYTESTORED\" JSON message. This function calculates reads the current used storage capacity from the\nmetadata file and sends it to the client. It's signature is as follows:\n\n\nsendShardCapacity()\n\n\n\n\nInput parameters:\n    None\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nSending requested file information to the client\n\n\nThe client requests the shard for the current used storage capacity using the following message\n\n\n{\n    MessageType: \"FILEINFO\"\n    Filename:\n    BytesFrom:\n    BytesTo:\n    BytesFrom2: \"\nfor copy from SHARD 2\n\"\n    BytesTo2: \"\nfor copy from SHARD 2\n\"\n    BytesFrom3: \"\nfor copy from SHARD 3\n\"\n    BytesTo3: \"\nfor copy from SHARD 3\n\"\n}\n\n\n\ngetFileInfo() function is responsible for responding to the \"FILEINFO\" JSON message. This function calculates reads the current used storage capacity from the\nmetadata file and sends it to the client. It's signature is as follows:\n\n\ngetFileInfo(filename)\n\n\n\n\nInput parameters:\n    string filename: The file for which information is to be retreived\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nSending requested data to the client\n\n\nThe client requests the shard for specific bytes of a file using the following message\n\n\n{\n    MessageType: \"REQUESTDATA\"\n    Filename:\n    BytesFrom:     \n    ByteTo:\n}\n\n\n\nsendFileData() function is responsible for responding to the \"REQUESTDATA\" JSON message. This function reads the requested bytes from the file, encodes the data into\nthe following JSON message using Base64 encoding and sends it to the client.\n\n\n{\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}\n\n\n\nThe signature of the function is as follows:\n\n\nsendFileData(req)\n\n\n\n\nInput parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nReceiving uploaded data from the client\n\n\nThe client uploads specific bytes of a file to the shard using the following message\n\n\n{\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}\n\n\n\nsaveFileUsingMetadata() function is responsible for storing the data at an appropriate location and also update the metadata accordingly. The signature of the function is as follows:\n\n\nsaveFileUsingMetadata(req)\n\n\n\n\nInput parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nSending backup data to other shards\n\n\nThe shards exchange backup data using the following message\n\n\n{\n    MessageType: \"BACKUPDATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}\n\n\n\nWhen a shard receives backup data it saves the file and updates the metadata accordingly. receiveBackupData() function is responsible for doing this. The signature of the function is as follows:\n\n\nreceiveBackupData(req)\n\n\n\n\nInput parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nSending local date-time to the client\n\n\nThis function has been implemented mostly for monitoring and debugging tools at the client side. When the shard receives the following message\n\n\n{\n    MessageType: \"TIMESTAMP\"\n    Timestamp:\n}\n\n\n\nIt responds by sending the dat and time at the server end to the requesting client. sendDateTimeToClient() is the function responsible for this.\n\n\nsendDateTimeToClient()\n\n\n\n\nInput parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Shard"
        }, 
        {
            "location": "/shardapi/#shard", 
            "text": "The shard is responsible for storing the files. To simplify this project, we will have shards also be the backups and develop the system so that it can tolerate the failure of one shard. Further, the system will support exactly three shards but the IP address and ports should not be hard coded in your code. Each shard connects to the other two shards, shard1 and shard2.\nThe shards, when they receive an upload file, they split the file into two equal parts and upload the \"backup\" to the other two shards. Thus each upload chunk is tagged as primary or backup on the shard. When calculating the total storage used on a shard, it reports the total of primary and backup storage.\nThe shard listens to the incoming connections from the clients. It also connects to the other shards in the network. It keeps a metadata of all the uploaded files and replicated files as backup.", 
            "title": "Shard"
        }, 
        {
            "location": "/shardapi/#replication", 
            "text": "In many distributed systems, such as storage systems in the cloud, the same data is copied to multiple servers in multiple geographical locations. Such copies of data are called replicas. Replicas are used to provide redundancy and reliability to storage system, i.e., if one copy of the data is lost, we still have another copy. In our project, we will replicate the data stored in the shards so that the system can survive the crash of one shard.\nIn this project, we will have each shard split the data it receives for storage into two pieces and copy them to the remaining two servers. That way, if a shard crashes, we have a copy of the data on the two remaining servers. The system will not be able to recover if more than one shard crashes.", 
            "title": "Replication"
        }, 
        {
            "location": "/shardapi/#system-components", 
            "text": "The shards are configured at start-up using a configuration file. Also, the shards store all metadata related to uploaded data in the metadata file.\nThe description and structure ofboth these files is presented below.", 
            "title": "System Components"
        }, 
        {
            "location": "/shardapi/#configuration-file", 
            "text": "Field  Description      homedir  Home directory for the shard and client. Each client and shard has a different home directory    listenport  Port at which this shard should listen for incoming connections    metadatafile  The file that stores the metadata corresponding to the files and replicates stored by the shard    shard1ip  IP address of shard 1    shard1port  Port of shard 1    shard2ip  IP address of shard 2    shard2port  Port of shard 2", 
            "title": "Configuration file"
        }, 
        {
            "location": "/shardapi/#metadata", 
            "text": "The home directory for the shard contains a metadata file specified in the configuration file. The metadata has information about the primary and backup data stored by the shard. This file is JSON format and contains the following fields:     Field  Description      Filename  Name of the file for which metadata is stored    BytesFrom1  Start index of primary data block    BytesTo1  End index of primary data block    Filename2  Name of the file for first backup block received from other shards    BytesFrom2  Start index of first backup data block    BytesTo2  End index of first backup data block    Filename3  Name of the file for second backup block received from other shards    BytesFrom3  Start index of second backup data block    BytesTo3  End index of second backup data block", 
            "title": "Metadata"
        }, 
        {
            "location": "/shardapi/#api-documentation", 
            "text": "The entire module has been developed using Python. The shard functionality is implemented using two classes    Shard:  \n   This is the main class for the shard and is responsible for listening for incoming client requests    ServerThread:  \n   This class is the main engine for the shard functionality. It derives from thread.Threading class. The Shard class creates an instance of this class\n   and passes all requests received from client to this instance. The ServerThread instance is then responsible for replying to all requests    The API documentation discussed below pertain to the ServerThread class unless otherwise mentioned", 
            "title": "API Documentation"
        }, 
        {
            "location": "/shardapi/#accepting-client-requests", 
            "text": "This function is the main engine of the ServerThread class. This function is responsible for determining the type of client request received\nand taking action accordingly.  acceptClientRequests()  Input parameters:\n    None\n\nReturn:\n    None  Known Limitations: To parse the JSON message received, it is assumed that the message won't won't contain more than one '}'", 
            "title": "Accepting client requests"
        }, 
        {
            "location": "/shardapi/#sending-used-storage-capacity-to-the-client", 
            "text": "The client requests the shard for the current used storage capacity using the following message  {\n    MessageType: \"BYTESTORED\"\n    ByteStored: \" value in bytes \"\n}  sendShardCapacity() function is responsible for responding to the \"BYTESTORED\" JSON message. This function calculates reads the current used storage capacity from the\nmetadata file and sends it to the client. It's signature is as follows:  sendShardCapacity()  Input parameters:\n    None\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Sending used storage capacity to the client"
        }, 
        {
            "location": "/shardapi/#sending-requested-file-information-to-the-client", 
            "text": "The client requests the shard for the current used storage capacity using the following message  {\n    MessageType: \"FILEINFO\"\n    Filename:\n    BytesFrom:\n    BytesTo:\n    BytesFrom2: \" for copy from SHARD 2 \"\n    BytesTo2: \" for copy from SHARD 2 \"\n    BytesFrom3: \" for copy from SHARD 3 \"\n    BytesTo3: \" for copy from SHARD 3 \"\n}  getFileInfo() function is responsible for responding to the \"FILEINFO\" JSON message. This function calculates reads the current used storage capacity from the\nmetadata file and sends it to the client. It's signature is as follows:  getFileInfo(filename)  Input parameters:\n    string filename: The file for which information is to be retreived\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Sending requested file information to the client"
        }, 
        {
            "location": "/shardapi/#sending-requested-data-to-the-client", 
            "text": "The client requests the shard for specific bytes of a file using the following message  {\n    MessageType: \"REQUESTDATA\"\n    Filename:\n    BytesFrom:     \n    ByteTo:\n}  sendFileData() function is responsible for responding to the \"REQUESTDATA\" JSON message. This function reads the requested bytes from the file, encodes the data into\nthe following JSON message using Base64 encoding and sends it to the client.  {\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}  The signature of the function is as follows:  sendFileData(req)  Input parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Sending requested data to the client"
        }, 
        {
            "location": "/shardapi/#receiving-uploaded-data-from-the-client", 
            "text": "The client uploads specific bytes of a file to the shard using the following message  {\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}  saveFileUsingMetadata() function is responsible for storing the data at an appropriate location and also update the metadata accordingly. The signature of the function is as follows:  saveFileUsingMetadata(req)  Input parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Receiving uploaded data from the client"
        }, 
        {
            "location": "/shardapi/#sending-backup-data-to-other-shards", 
            "text": "The shards exchange backup data using the following message  {\n    MessageType: \"BACKUPDATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}  When a shard receives backup data it saves the file and updates the metadata accordingly. receiveBackupData() function is responsible for doing this. The signature of the function is as follows:  receiveBackupData(req)  Input parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Sending backup data to other shards"
        }, 
        {
            "location": "/shardapi/#sending-local-date-time-to-the-client", 
            "text": "This function has been implemented mostly for monitoring and debugging tools at the client side. When the shard receives the following message  {\n    MessageType: \"TIMESTAMP\"\n    Timestamp:\n}  It responds by sending the dat and time at the server end to the requesting client. sendDateTimeToClient() is the function responsible for this.  sendDateTimeToClient()  Input parameters:\n    dict req: The message received, which contains all the required data for reading the file\n\nReturn:\n    None  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Sending local date-time to the client"
        }, 
        {
            "location": "/client/", 
            "text": "Client\n\n\nThe client is a socket program that interacts with the shards to determine how much data to upload to each shard. Then it uploads the appropriate amount of data to the shards. The client tries to balance the total amount of storage utilized on the shards. For example, if shard1 happens to store more data than shard2 and shard3, the client will upload more data to shard1 than shard2 and shard3. Ideally, shards 1, 2, and 3 will have exactly the same amount of data after each upload but that will never be the case because of how the shards are replicated but we will try to get as close to balanced storage as possible.\n\n\nSystem Components\n\n\nThe client is configured at startup using the configuration file. The description and structure os this file is presented below.\n\n\nConfiguration file\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhomedir\n\n\nHome directory for the shard and client. Each client and shard has a different home directory\n\n\n\n\n\n\nmetadatafile\n\n\nThe file that stores the metadata corresponding to the files and replicates stored by the shard\n\n\n\n\n\n\nshard1ip\n\n\nIP address of shard 1\n\n\n\n\n\n\nshard1port\n\n\nPort of shard 1\n\n\n\n\n\n\nshard2ip\n\n\nIP address of shard 2\n\n\n\n\n\n\nshard2port\n\n\nPort of shard 2\n\n\n\n\n\n\nshard3ip\n\n\nIP address of shard 3\n\n\n\n\n\n\nshard3port\n\n\nPort of shard 3\n\n\n\n\n\n\n\n\nLoad balancing algorithm\n\n\nThe client queries the used storage capacity at each shard and based on these observations, tries to distribute the data such that the load at all the shards is balanced as far as possible.\nThe pseudocode for the load balancing algorithm is as follows:\n\n\ntotalsize = size_shard1 + size_shard2 + size_shard3 + filesize\nsize_per_shard = totalsize/3\nremainder = totalsize%3\n\nhave a list/dictionary of all shards\nfor all shards\n  if size_shard \n= size_per_shard\n  then remove_shard from list of shards that receive a chunk of the file\n\nfor shards left in the list\n  size of shard = size_per_shard - size_shard + remainder\n  remainder = 0 // since remainder was added to the first shard\n\n\n\n\nA special thanks to Ahmed Saeed for helping me out with the load balancing algorithm\n\n\nAPI Documentation\n\n\n\n\nThe entire module has been developed using Python. The shard functionality is implemented using a sinlge class \nClient\n. On initialization, the instance of this object is configured using the config file.\nBased on the command line arguments given to the client, the client will upload/download data\n\n\n\n\nConnecting to shards\n\n\nThe client connects to the shards using the following function\n\n\nconnectToShards()\n\n\n\n\nInput parameters:\n    None\n\nReturn:\n    List of server sockets\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nRequesting shard storage capacity\n\n\nThe client requests the used storage capacity at each active shard using the following message\n\n\n{\n    MessageType: \"BYTESTORED\"\n    ByteStored: \"\nvalue in bytes\n\"\n}\n\n\n\nqueryShardCapacities() function is responsible for handling this.\n\n\nqueryShardCapacities()\n\n\n\n\nInput parameters:\n    None\n\nReturn:\n    List of shard capacities corresoponding to the shard\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nUpload file to shards\n\n\nBased on the shard storage values obtained, the client calculates how much data is to be stored at each shard and sends the corresponding bytes to the shards using the following message`\n\n\n{\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}\n\n\n\nuploadFileToShards() function is responsible for handling this.\n\n\nuploadFileToShards(shardCapacity, dataFile)\n\n\n\n\nInput parameters:\n    shardCapacity: List containing used storage at each shard\n    dataFile: The file to be uploaded\n\nReturn:\n    List of shard capacities corresoponding to the shard\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\n\n\nDownload file from shards\n\n\nWhen the client wants to download files, it will query each shard for the file using the follwoing message\n\n\n{\n    MessageType: \"FILEINFO\"\n    Filename:\n    BytesFrom:\n    BytesTo:\n    BytesFrom2: \"\nfor copy from SHARD 2\n\"\n    BytesTo2: \"\nfor copy from SHARD 2\n\"\n    BytesFrom3: \"\nfor copy from SHARD 3\n\"\n    BytesTo3: \"\nfor copy from SHARD 3\n\"\n}\n\n\n\nOn obtaining the fileinfo, the client requests the corresponding bytes from the shards using the following message\n\n\n{\n    MessageType: \"REQUESTDATA\"\n    Filename:\n    BytesFrom:     \n    ByteTo:\n}\n\n\n\nOn receiving the bytes, the client puts the bytes in order and stores the file. downloadFile() is the function responsible for this.\n\n\ndownloadFile(metadata)\n\n\n\n\nInput parameters:\n    metadata: List containing the fileinfo returned by each individual shard\n\nReturn:\n    List of shard capacities corresoponding to the shard\n\n\n\nKnown Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases\n\n\nIf the client cannot find all three shards active, the client uses the downloadBackupData(). This distinction is done because incase of a shard being down, the client will have to send additional \"FILEINFO\" and \"REQUESTDATA\" messages to download backup data from the remaining shards.", 
            "title": "Client"
        }, 
        {
            "location": "/client/#client", 
            "text": "The client is a socket program that interacts with the shards to determine how much data to upload to each shard. Then it uploads the appropriate amount of data to the shards. The client tries to balance the total amount of storage utilized on the shards. For example, if shard1 happens to store more data than shard2 and shard3, the client will upload more data to shard1 than shard2 and shard3. Ideally, shards 1, 2, and 3 will have exactly the same amount of data after each upload but that will never be the case because of how the shards are replicated but we will try to get as close to balanced storage as possible.", 
            "title": "Client"
        }, 
        {
            "location": "/client/#system-components", 
            "text": "The client is configured at startup using the configuration file. The description and structure os this file is presented below.", 
            "title": "System Components"
        }, 
        {
            "location": "/client/#configuration-file", 
            "text": "Field  Description      homedir  Home directory for the shard and client. Each client and shard has a different home directory    metadatafile  The file that stores the metadata corresponding to the files and replicates stored by the shard    shard1ip  IP address of shard 1    shard1port  Port of shard 1    shard2ip  IP address of shard 2    shard2port  Port of shard 2    shard3ip  IP address of shard 3    shard3port  Port of shard 3", 
            "title": "Configuration file"
        }, 
        {
            "location": "/client/#load-balancing-algorithm", 
            "text": "The client queries the used storage capacity at each shard and based on these observations, tries to distribute the data such that the load at all the shards is balanced as far as possible.\nThe pseudocode for the load balancing algorithm is as follows:  totalsize = size_shard1 + size_shard2 + size_shard3 + filesize\nsize_per_shard = totalsize/3\nremainder = totalsize%3\n\nhave a list/dictionary of all shards\nfor all shards\n  if size_shard  = size_per_shard\n  then remove_shard from list of shards that receive a chunk of the file\n\nfor shards left in the list\n  size of shard = size_per_shard - size_shard + remainder\n  remainder = 0 // since remainder was added to the first shard  A special thanks to Ahmed Saeed for helping me out with the load balancing algorithm", 
            "title": "Load balancing algorithm"
        }, 
        {
            "location": "/client/#api-documentation", 
            "text": "The entire module has been developed using Python. The shard functionality is implemented using a sinlge class  Client . On initialization, the instance of this object is configured using the config file.\nBased on the command line arguments given to the client, the client will upload/download data", 
            "title": "API Documentation"
        }, 
        {
            "location": "/client/#connecting-to-shards", 
            "text": "The client connects to the shards using the following function  connectToShards()  Input parameters:\n    None\n\nReturn:\n    List of server sockets  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Connecting to shards"
        }, 
        {
            "location": "/client/#requesting-shard-storage-capacity", 
            "text": "The client requests the used storage capacity at each active shard using the following message  {\n    MessageType: \"BYTESTORED\"\n    ByteStored: \" value in bytes \"\n}  queryShardCapacities() function is responsible for handling this.  queryShardCapacities()  Input parameters:\n    None\n\nReturn:\n    List of shard capacities corresoponding to the shard  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Requesting shard storage capacity"
        }, 
        {
            "location": "/client/#upload-file-to-shards", 
            "text": "Based on the shard storage values obtained, the client calculates how much data is to be stored at each shard and sends the corresponding bytes to the shards using the following message`  {\n    MessageType: \"DATA\"\n    Filename:\n    BytesFrom:     \n    BytesTo:\n    Data:   \n}  uploadFileToShards() function is responsible for handling this.  uploadFileToShards(shardCapacity, dataFile)  Input parameters:\n    shardCapacity: List containing used storage at each shard\n    dataFile: The file to be uploaded\n\nReturn:\n    List of shard capacities corresoponding to the shard  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases", 
            "title": "Upload file to shards"
        }, 
        {
            "location": "/client/#download-file-from-shards", 
            "text": "When the client wants to download files, it will query each shard for the file using the follwoing message  {\n    MessageType: \"FILEINFO\"\n    Filename:\n    BytesFrom:\n    BytesTo:\n    BytesFrom2: \" for copy from SHARD 2 \"\n    BytesTo2: \" for copy from SHARD 2 \"\n    BytesFrom3: \" for copy from SHARD 3 \"\n    BytesTo3: \" for copy from SHARD 3 \"\n}  On obtaining the fileinfo, the client requests the corresponding bytes from the shards using the following message  {\n    MessageType: \"REQUESTDATA\"\n    Filename:\n    BytesFrom:     \n    ByteTo:\n}  On receiving the bytes, the client puts the bytes in order and stores the file. downloadFile() is the function responsible for this.  downloadFile(metadata)  Input parameters:\n    metadata: List containing the fileinfo returned by each individual shard\n\nReturn:\n    List of shard capacities corresoponding to the shard  Known Limitations: Although testing for this function has been done for known use cases, it has not been tested rigorously for corner cases  If the client cannot find all three shards active, the client uses the downloadBackupData(). This distinction is done because incase of a shard being down, the client will have to send additional \"FILEINFO\" and \"REQUESTDATA\" messages to download backup data from the remaining shards.", 
            "title": "Download file from shards"
        }, 
        {
            "location": "/monitor/", 
            "text": "Monitor\n\n\nThe monitor is a diagnostic utility and is responsible for collecting the used storage at each shard after every 10 seconds.\n\n\nSystem Components\n\n\nThe monitor is configured at startup using the configuration file. The description and structure os this file is presented below.\n\n\nConfiguration file\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhomedir\n\n\nHome directory for the shard and client. Each client and shard has a different home directory\n\n\n\n\n\n\nmetadatafile\n\n\nThe file that stores the metadata corresponding to the files and replicates stored by the shard\n\n\n\n\n\n\nshard1ip\n\n\nIP address of shard 1\n\n\n\n\n\n\nshard1port\n\n\nPort of shard 1\n\n\n\n\n\n\nshard2ip\n\n\nIP address of shard 2\n\n\n\n\n\n\nshard2port\n\n\nPort of shard 2\n\n\n\n\n\n\nshard3ip\n\n\nIP address of shard 3\n\n\n\n\n\n\nshard3port\n\n\nPort of shard 3\n\n\n\n\n\n\n\n\nAPI Documentation\n\n\n\n\nThe entire module has been developed using Python. The monitor connects to the three shards usning the configuration file.\nAlso the monitor uses the same API calls that the client uses.\n\n\n\n\nMeasurements\n\n\nInitially the shards are configured with different storage using the shards metadata. The monitor notes down the storage amount returned by the shards in a CSV file.\nThe graph of the measurements is given below.\n\n\n\nAs seen above, we see that initially shard1 has used more storage capacity than the other shards. Over a period of time, the client keeps uploading a file of 10 KB to the shards.\nThe storage capacity is still not balanced out  because backup data is being sent to shard 1. However, towards the end the client makes uploads of a few large files. It is at these points that we see the storage capacities slowly start to balance out.\nThus, we can conclude that the load balancing algorithm is working as expected.", 
            "title": "Monitor"
        }, 
        {
            "location": "/monitor/#monitor", 
            "text": "The monitor is a diagnostic utility and is responsible for collecting the used storage at each shard after every 10 seconds.", 
            "title": "Monitor"
        }, 
        {
            "location": "/monitor/#system-components", 
            "text": "The monitor is configured at startup using the configuration file. The description and structure os this file is presented below.", 
            "title": "System Components"
        }, 
        {
            "location": "/monitor/#configuration-file", 
            "text": "Field  Description      homedir  Home directory for the shard and client. Each client and shard has a different home directory    metadatafile  The file that stores the metadata corresponding to the files and replicates stored by the shard    shard1ip  IP address of shard 1    shard1port  Port of shard 1    shard2ip  IP address of shard 2    shard2port  Port of shard 2    shard3ip  IP address of shard 3    shard3port  Port of shard 3", 
            "title": "Configuration file"
        }, 
        {
            "location": "/monitor/#api-documentation", 
            "text": "The entire module has been developed using Python. The monitor connects to the three shards usning the configuration file.\nAlso the monitor uses the same API calls that the client uses.", 
            "title": "API Documentation"
        }, 
        {
            "location": "/monitor/#measurements", 
            "text": "Initially the shards are configured with different storage using the shards metadata. The monitor notes down the storage amount returned by the shards in a CSV file.\nThe graph of the measurements is given below.  As seen above, we see that initially shard1 has used more storage capacity than the other shards. Over a period of time, the client keeps uploading a file of 10 KB to the shards.\nThe storage capacity is still not balanced out  because backup data is being sent to shard 1. However, towards the end the client makes uploads of a few large files. It is at these points that we see the storage capacities slowly start to balance out.\nThus, we can conclude that the load balancing algorithm is working as expected.", 
            "title": "Measurements"
        }
    ]
}